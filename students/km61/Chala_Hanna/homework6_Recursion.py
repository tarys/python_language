"""
1. Чётные индексы.
Выведите все элементы списка с четными индексами (то есть A[0], A[2], A[4], ...).
"""
a=[int(i) for i in input().split()]
def lists(a,i):
    if i>=len(a):
        return
    print (a[i])
    lists(a,i+2)
lists(a,0)



"""
2. Чётные елементы.
Выведите все четные элементы списка. При этом используйте цикл for, перебирающий элементы списка, а не их индексы!
"""
a = [int(i) for i in input().split()]
    
def f1(i):
    if i >= len(a):
        return
    if a[i] % 2 == 0:
        print(a[i])
    f1(i + 1)
    
f1(0)


"""
3. Больше предыдущего.
Дан список чисел. Выведите все элементы списка, которые больше предыдущего элемента.
"""
 = [int(i) for i in input().split()]
def f1 (zz):
    global a

    if zz==len(a):
        return
    if zz != 0:
        if a[zz] > a[zz-1]:
            print(a[zz])
    
    f1 (zz+1)
f1(0)


"""
4. Соседи одного знака.
Дан список чисел. Если в нем есть два соседних элемента одного знака, выведите эти числа. Если соседних элементов одного знака нет — не выводите ничего. Если таких пар соседей несколько — выведите первую пару.
"""
a = [int(i) for i in input().split()]
def f1(z):
    global a
    if z==len(a)-1:
        return
    if a[z]*a[z+1]>0:
        print (a[z],a[z+1])
        return
    f1(z+1)
f1(0)


"""
5. Больше своих соседей.
Дан список чисел. Определите, сколько в этом списке элементов, которые больше двух своих соседей, и выведите количество таких элементов. Крайние элементы списка никогда не учитываются, поскольку у них недостаточно соседей.
"""
a = [int(i) for i in input().split()]
def f1(z):
    n = 0
    if z == len(a)-1:
        return n
    if (z != 0) and (a[z-1] < a[z] > a[z+1]):
        n += 1
    return n + f1(z+1)
        
print(f1(0))


"""
6. Наибольший елемент.
Дан список чисел. Выведите значение наибольшего элемента в списке, а затем индекс этого элемента в списке. Если наибольших элементов несколько, выведите индекс первого из них.
"""
a = [int(i) for i in input().split()]
x = 0

def f1(max, x, i):
    n = 0
    if i >= len(a):
        return max, x
    if a[i] > max:
        max = a[i]
        x = i
    return f1(max, x, i + 1)
    
print(' '.join([str(i) for i in f1(a[0], 0, 1)]))


"""
7. Шеренга.
Петя перешёл в другую школу. На уроке физкультуры ему понадобилось определить своё место в строю. Помогите ему это сделать.
Программа получает на вход невозрастающую последовательность натуральных чисел, означающих рост каждого человека в строю. После этого вводится число X – рост Пети. Все числа во входных данных натуральные и не превышают 200.

Выведите номер, под которым Петя должен встать в строй. Если в строю есть люди с одинаковым ростом, таким же, как у Пети, то он должен встать после них.
"""
a = [int(i) for i in input().split()]
x=int(input())
def f1(z,n,x):
    if z>=len(a):
        return (z+1)
    if a[z] < x:
        n = z+1
        return (n)
    return (f1(z+1,n,x))
print (f1(0,1,x))


"""
8. Количество различных елементов.
Дан список, упорядоченный по неубыванию элементов в нем. Определите, сколько в нем различных элементов.
"""
a = [int(i) for i in input().split()]
def f1(n,z):
    if z>=len(a)-1:
        return (n)
    if a[z] != a[z+1]:
        n += 1
    return (f1(n,z+1))
print (f1(1,0))


"""
9. Переставить соседние.
Переставьте соседние элементы списка (A[0] c A[1], A[2] c A[3] и т. д.). Если элементов нечетное число, то последний элемент остается на своем месте.
"""
a = [int(i) for i in input().split()]
def f1(z):
    if z>=len(a):
        return
    a[z],a[z-1] = a[z-1],a[z]
    f1(z+2)
f1(1)
print (' '.join([str(i) for i in a]))


"""
10. Переставить min и max
В списке все элементы различны. Поменяйте местами минимальный и максимальный элемент этого списка.
"""
a = [int(i) for i in input().split()]
def f1(z,min,max):
    if z == len(a):
        a[max],a[min] = a[min],a[max]
        return (a)
    if a[z] > a[max]:
        max = z
    if a[z] < a[min]:
        min = z
    return f1(z+1,min,max)
    
    
f1(0,0,0)
print(' '.join([str(i) for i in a]))


"""
11. Удалить елемент.
Дан список из чисел и индекс элемента в списке k. Удалите из списка элемент с индексом k, сдвинув влево все элементы, стоящие правее элемента с индексом k.
Программа получает на вход список, затем число k. Программа сдвигает все элементы, а после этого удаляет последний элемент списка при помощи метода pop() без параметров.

Программа должна осуществлять сдвиг непосредственно в списке, а не делать это при выводе элементов. Также нельзя использовать дополнительный список. Также не следует использовать метод pop(k) с параметром.
"""
a = [int(i) for i in input().split()] 
k = int(input()) 
def f1(i): 
    if i >= len(a): 
        a.pop() 
        print(' '.join([str(i) for i in a])) 
        return 
    a[i], a[i - 1] = a[i - 1], a[i] 
    f1(i + 1)
f1(k+1)


"""
12. Вставить елемент.
Дан список целых чисел, число k и значение C. Необходимо вставить в список на позицию с индексом k элемент, равный C, сдвинув все элементы, имевшие индекс не менее k, вправо.
Посколько при этом количество элементов в списке увеличивается, после считывания списка в его конец нужно будет добавить новый элемент, используя метод append.

Вставку необходимо осуществлять уже в считанном списке, не делая этого при выводе и не создавая дополнительного списка.
"""
a = [int(i) for i in input().split()]
k, n = [int(i) for i in input().split()]

def f1(a, n, i):
    if i >= len(a):
        a.append(n) 
        return
    a[i], n = n, a[i]
    f1(a, n, i + 1)

f1(a, n, k)
print(' '.join([str(i) for i in a]))


"""
13.Количество совпадающих пар.
Дан список чисел. Посчитайте, сколько в нем пар элементов, равных друг другу. Считается, что любые два элемента, равные друг другу образуют одну пару, которую необходимо посчитать.
"""
a = [int(i) for i in input().split()]

def f1(n, i):
    if i >= len(a):
        return n
    n = f2(n, a[i], i + 1)
    return f1(n, i + 1)
    
def f2(n, x, j):
    if j >= len(a):
        return n
    if a[j] == x:
        n += 1
    return f2(n, x, j + 1)    
    
print(f1(0, 0))


"""
14.Уникальные елементы.
Дан список. Выведите те его элементы, которые встречаются в списке только один раз. Элементы нужно выводить в том порядке, в котором они встречаются в списке.
"""
a = [int(i) for i in input().split()]

def f1(n, i):
    if i >= len(a):
        return n
    if f2(i, 0):
        print(a[i])
    return f1(n, i + 1)
    
def f2(x, j):
    if j >= len(a):
        return True
    if a[j] == a[x] and j != x:
        return False
    return f2(x, j + 1)    
    
f1(0, 0)


"""
15.Кегельбан.
N кеглей выставили в один ряд, занумеровав их слева направо числами от 1 до N. Затем по этому ряду бросили K шаров, при этом i-й шар сбил все кегли с номерами от li до ri включительно. Определите, какие кегли остались стоять на месте.
Программа получает на вход количество кеглей N и количество бросков K. Далее идет K пар чисел li, ri, при этом 1? li? ri? N.

Программа должна вывести последовательность из N символов, где j-й символ есть “I”, если j-я кегля осталась стоять, или “.”, если j-я кегля была сбита.
"""
n, k = [int(i) for i in input().split()]
play = [[int(i) for i in input().split()] for j in range(k)]

def f1(play, i):
    if i >= n + 1:
        return
    if fail(play, i, 0):
        print('I', end = '')
    else:
        print('.', end = '')
    f1(play, i + 1)
    
def fail(play, i, j):
    if j >= len(play):
        return True
    if i >= play[j][0] and i <= play[j][1]:
        return False
    return fail(play, i, j + 1)    
    
f1(play, 1)


"""
16.Ферзи.
Известно, что на доске 8?8 можно расставить 8 ферзей так, чтобы они не били друг друга. Вам дана расстановка 8 ферзей на доске, определите, есть ли среди них пара бьющих друг друга.
Программа получает на вход восемь пар чисел, каждое число от 1 до 8 — координаты 8 ферзей. Если ферзи не бьют друг друга, выведите слово NO, иначе выведите YES.
"""
queens = [[int(i) for i in input().split()] for j in range(8)]

def f1(queens, i):
    if i >= len(queens):
        return False
    if win(queens, i, 0):
        return True
    return f1(queens, i + 1)
    
def win(queens, i, j):
    if j >= len(queens):
        return False
    x1 = queens[i][0]
	y1 = queens[i][1]
    x2 = queens[j][0]
    y2 = queens[j][1]
    if (x1 == x2 or y1 == y2 or abs(x1-x2) == abs(y1-y2)) and i != j:
        return True
    return win(queens, i, j + 1)    

if f1(queens, 0):
    print('YES')
else:
    print('NO')